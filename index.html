<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>수강생 시트 자동 업데이트 (카드 + 계좌 · B2~N 전송)</title>
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <!-- Google API (Sheets) -->
  <script src="https://apis.google.com/js/api.js" async defer></script>
  <style>
    .toast{position:fixed;right:16px;bottom:16px;padding:10px 14px;border-radius:10px;background:#0f172a;color:#fff;opacity:.96;box-shadow:0 6px 20px rgba(0,0,0,.2);z-index:1000}
    .scroll-xy{overflow:auto}
    table.preview{border-collapse:collapse}
    table.preview td,table.preview th{border:1px solid #e5e7eb;padding:8px;white-space:nowrap}
    .invalid{background:#fef2f2;color:#991b1b}
    .fname{font-size:12px;color:#475569}
  </style>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-6xl mx-auto p-6">
    <header class="mb-6">
      <h1 class="text-xl md:text-2xl font-bold">수강생 시트 자동 업데이트</h1>
      <p class="text-sm text-slate-600 mt-1">좌: 카드 CSV · 우: 계좌(원장 tickets + 응답 responses). K(결제시간) 기준 오래된→최신 정렬. 전송 시 항상 <b>B2~N</b>만 초기화 후 덮어쓰기.</p>
    </header>

    <section class="grid lg:grid-cols-2 gap-6 mb-6">
      <!-- 카드 -->
      <div class="space-y-3 bg-white border border-slate-200 rounded-xl p-4">
        <h2 class="font-semibold">① 카드결제 CSV</h2>
        <input id="csvCard" type="file" accept="text/csv,.csv" class="block w-full text-sm" />
        <div id="nameCard" class="fname"></div>
        <label class="inline-flex items-center gap-2 text-sm">
          <input type="checkbox" id="headCard" class="accent-blue-600" checked /> 첫 행은 헤더(건너뛰기)
        </label>
      </div>

      <!-- 계좌이체 -->
      <div class="space-y-3 bg-white border border-slate-200 rounded-xl p-4">
        <h2 class="font-semibold">② 계좌이체 CSV 2개</h2>
        <div class="grid sm:grid-cols-2 gap-3">
          <div>
            <label class="block text-sm font-semibold mb-1">tickets.csv (입출금 원장)</label>
            <input id="csvTicket" type="file" accept="text/csv,.csv" class="block w-full text-sm" />
            <div id="nameTicket" class="fname"></div>
            <label class="inline-flex items-center gap-2 text-xs mt-1">
              <input type="checkbox" id="headTicket" class="accent-blue-600" checked /> 첫 행은 헤더
            </label>
          </div>
          <div>
            <label class="block text-sm font-semibold mb-1">responses.csv (신청/응답)</label>
            <input id="csvResp" type="file" accept="text/csv,.csv" class="block w-full text-sm" />
            <div id="nameResp" class="fname"></div>
            <label class="inline-flex items-center gap-2 text-xs mt-1">
              <input type="checkbox" id="headResp" class="accent-blue-600" checked /> 첫 행은 헤더
            </label>
          </div>
        </div>
      </div>
    </section>

    <!-- 옵션 -->
    <section class="grid lg:grid-cols-2 gap-6 mb-6">
      <div class="space-y-3 bg-white border border-slate-200 rounded-xl p-4">
        <h2 class="font-semibold">미리보기 / 전송 옵션</h2>

        <div class="flex items-center gap-3 mb-2">
          <label class="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" id="optHasHeader" class="accent-blue-600" checked /> 첫 행은 헤더
          </label>
          <label class="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" id="optMaskPhone" class="accent-blue-600" /> 전화번호 마스킹(미리보기)
          </label>
        </div>

        <div class="grid grid-cols-3 gap-3 items-end">
          <div class="col-span-3">
            <label class="block text-sm font-semibold mb-1">Google 시트 URL 또는 ID</label>
            <input id="sheetUrl" type="text" class="w-full p-3 rounded-lg border border-slate-200 bg-white" placeholder="https://docs.google.com/spreadsheets/d/XXXXXXXXX/edit" />
          </div>
          <div class="col-span-2">
            <label class="block text-sm font-semibold mb-1">시트 선택(드롭다운)</label>
            <select id="sheetPicker" class="w-full p-3 rounded-lg border border-slate-200 bg-white">
              <option value="">(먼저 연결 후 ‘시트 목록 불러오기’를 누르세요)</option>
            </select>
          </div>
          <div>
            <button id="btnLoadSheets" class="w-full px-3 py-2 rounded-lg border border-slate-300 bg-white hover:bg-slate-100 text-sm" type="button">
              시트 목록 불러오기
            </button>
          </div>
        </div>

        <div class="grid grid-cols-2 gap-3 mt-2">
          <button id="connectBtn" type="button" class="px-3 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700">
            Google 계정 연결
          </button>
          <select id="valueInputOption" class="p-3 rounded-lg border border-slate-200 bg-white">
            <option value="USER_ENTERED">USER_ENTERED (권장)</option>
            <option value="RAW">RAW</option>
          </select>
        </div>
        <div class="text-xs text-slate-500">
          전송 시 헤더는 자동 제외됩니다. (항상 B2~N 초기화 후 덮어쓰기)
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-2">
        <button id="btnPreviewCsv" type="button" class="px-3 py-2 rounded-lg bg-slate-900 text-white hover:bg-black">
          정리 미리보기
        </button>
        <button id="btnClear" type="button" class="px-3 py-2 rounded-lg border border-slate-300 bg-white hover:bg-slate-100">
          초기화
        </button>
        <button id="btnSend" type="button" class="px-3 py-2 rounded-lg bg-emerald-600 text-white disabled:opacity-50" disabled>
          Google 시트로 전송
        </button>
        <span id="authState" class="text-xs text-slate-600 ml-2">미연결</span>
      </div>
    </section>

    <!-- Preview -->
    <section class="bg-white rounded-xl border border-slate-200 p-4">
      <div class="flex items-center justify-between mb-3">
        <h2 class="font-semibold">
          정리 시트 미리보기 <span class="text-xs text-slate-400">(K열 오름차순 · 카드 후 계좌)</span>
        </h2>
        <div class="text-xs text-slate-500" id="summary"></div>
      </div>
      <div class="scroll-xy" style="max-height: 520px;">
        <table id="previewTable" class="preview text-sm"></table>
      </div>
    </section>
  </div>

  <div id="toast" class="toast hidden"></div>

  <script>
  /* =================== 기본 설정 =================== */
  const OAUTH_CLIENT_ID = "18228268359-iifm4ck3j9kqj74eh1p90tco1k2mbpi0.apps.googleusercontent.com"; // 본인 OAuth 클라ID
  const OAUTH_SCOPES   = "https://www.googleapis.com/auth/spreadsheets";

  let tokenClient=null, oauthReady=false;
  let parsedRows=[];                 // 헤더+본체
  let csvCard=[], csvTickets=[], csvResp=[];

  const $ = (q)=>document.querySelector(q);
  const toast = (msg, type="info")=>{
    const el=$("#toast"); if(!el) return;
    el.textContent=msg; el.classList.remove("hidden");
    el.style.background = type==='error' ? '#991b1b' : (type==='ok' ? '#065f46' : '#0f172a');
    setTimeout(()=> el.classList.add("hidden"), 2600);
  };

  const ensureArrayLen=(len)=>{const a=new Array(len); for(let i=0;i<len;i++) a[i]=''; return a;};
  const equalizeRowLength=(rows)=>{ if(!rows.length) return rows; const m=rows.reduce((p,r)=>Math.max(p,r.length),0); return rows.map(r=>{const c=r.slice(); while(c.length<m) c.push(''); return c;}); };

  const maskPhones=(rows)=>{
    const re1=/(\b\d{3})(\d{4})(\d{4}\b)/g, re2=/(\b\d{2,3}-)(\d{3,4})(-\d{4}\b)/g;
    return rows.map(row=> row.map(cell=>{
      if(typeof cell!=='string') return cell;
      let out=cell.replace(re1,(m,a,b,c)=>`${a}****${c}`);
      out=out.replace(re2,(m,a,b,c)=>`${a}****${c}`);
      return out;
    }));
  };

  const normName=(s)=> String(s||'').trim()
    .replace(/[\s]*[\(\[\{（【][^)\]\}）】]*[\)\]\}）】]\s*$/,'') // 괄호 끝장식 제거
    .replace(/[/_\-\s]+$/,'')                                  // 끝 슬래시류 제거
    .replace(/\s+/g,' ')
    .trim();

  function parseMoney(v){
    const s=String(v??'').replace(/[^\d\-\.\,()]/g,'');
    if(!s) return 0;
    let neg=false, t=s;
    if(/\(/.test(t) && /\)/.test(t)) { neg=true; t=t.replace(/[()]/g,''); }
    t=t.replace(/,/g,'');
    if(/^-/.test(t)) neg=!neg;
    const n=parseFloat(t);
    return (neg?-1:1) * (isNaN(n)?0:n);
  }

  function findColIndex(head, names){
    const H=(head||[]).map(x=>String(x||'').toLowerCase().trim());
    for(let i=0;i<H.length;i++){
      for(const nm of names){ if(H[i].includes(String(nm).toLowerCase())) return i; }
    }
    return -1;
  }

  /* =================== 날짜 파싱 =================== */
  function getTimeFromAny(val){
    if(val===undefined || val===null) return NaN;
    const s0=String(val).trim(); if(!s0) return NaN;
    const pm=/오후/.test(s0), am=/오전/.test(s0);
    const m=s0.match(/(\d{4})\D(\d{1,2})\D(\d{1,2})(?:\D+(\d{1,2})(?::(\d{1,2})(?::(\d{1,2}))?)?)?/);
    if(m){
      let [,yy,MM,dd,hh,mm,ss]=m;
      let H=hh?parseInt(hh,10):0, Mi=mm?parseInt(mm,10):0, S=ss?parseInt(ss,10):0;
      if(pm && H<12) H+=12; if(am && H===12) H=0;
      return new Date(+yy, +MM-1, +dd, H, Mi, S).getTime();
    }
    const iso=s0.replace(/[./]/g,'-').replace('T',' '); const t=Date.parse(iso);
    return isNaN(t)?NaN:t;
  }

  /* =================== Google API =================== */
  async function ensureGapiLoaded(){
    await new Promise(res=>{const chk=()=>{if(window.gapi && gapi.load){res();} else setTimeout(chk,50);}; chk();});
    await new Promise((res,rej)=>{ gapi.load('client', async ()=>{ try{ await gapi.client.load('https://sheets.googleapis.com/$discovery/rest?version=v4'); res(); }catch(e){ rej(e); } }); });
  }
  async function ensureAuth(){
    if(!window.google?.accounts?.oauth2) throw new Error('GIS not loaded');
    if(!tokenClient){
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: OAUTH_CLIENT_ID,
        scope: OAUTH_SCOPES,
        callback: (resp)=>{ 
          if(resp?.access_token){ 
            gapi.client.setToken({access_token:resp.access_token}); 
            oauthReady=true; 
            updateAuthUI(); 
            toast('Google 계정 연결 완료','ok'); 
          } else toast('인증 실패','error'); 
        }
      });
    }
    if(!oauthReady) tokenClient.requestAccessToken({prompt:'consent'});
  }
  function parseSpreadsheetId(input){ 
    if(!input) return ''; 
    const m=input.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/); 
    return m && m[1] ? m[1] : input.trim(); 
  }

  async function listSheets(spreadsheetId){
    const res = await gapi.client.sheets.spreadsheets.get({ spreadsheetId, fields: "sheets(properties(title))" });
    const arr = (res.result?.sheets||[]).map(x=> x.properties?.title).filter(Boolean);
    return arr;
  }

  async function clearRange(spreadsheetId, range){
    return await gapi.client.sheets.spreadsheets.values.clear({ spreadsheetId, range });
  }
  async function writeFromB2(values){
    const spreadsheetId = parseSpreadsheetId($('#sheetUrl').value);
    if(!spreadsheetId) { toast('스프레드시트 URL/ID를 입력하세요','error'); throw new Error('no sheet'); }
    const sheetName = ($('#sheetPicker').value || 'Sheet1');
    const valueInputOption = $('#valueInputOption').value;

    // B2~N 전체 비우기
    await clearRange(spreadsheetId, `${sheetName}!B2:N`);

    // 내부 배열은 [A..N] 14열 구조 → B..N만 기록 (index 1..13 → 13개)
    const valuesBN = values.map(r=>{
      const row = Array.isArray(r)? r : [];
      const sl = row.slice(1, 14); // B..N
      while(sl.length < 13) sl.push('');
      return sl;
    });

    const res = await gapi.client.sheets.spreadsheets.values.update({
      spreadsheetId,
      range: `${sheetName}!B2`,
      valueInputOption,
      resource: { range: `${sheetName}!B2`, majorDimension:'ROWS', values: valuesBN }
    });
    return res.result?.updatedRows ?? valuesBN.length;
  }

  /* =================== CSV 로드 =================== */
  function readCsv(file){
    return new Promise((resolve)=>{
      if(!file){ resolve([]); return; }
      Papa.parse(file,{
        complete:(res)=>{
          let rows=Array.isArray(res.data)?res.data:[];
          rows=rows.map(r=> Array.isArray(r)?r:[r]);
          const cnt=rows.filter(r=> r.some(c=> String(c).trim()!=='')).length;
          if(cnt>0){ resolve(rows); return; }
          const tryEnc=['UTF-8','EUC-KR','CP949','ISO-8859-1']; let idx=0;
          const fr=new FileReader();
          fr.onload=()=>{ 
            const parsed=Papa.parse(String(fr.result||''),{skipEmptyLines:'greedy'}); 
            let r=Array.isArray(parsed.data)?parsed.data:[]; 
            r=r.map(x=>Array.isArray(x)?x:[x]); 
            const c=r.filter(x=>x.some(y=>String(y).trim()!=='')).length; 
            if(c>0 || idx>=tryEnc.length-1) resolve(r); 
            else { idx++; fr.readAsText(file, tryEnc[idx]); } 
          };
          fr.onerror=()=>resolve([]);
          fr.readAsText(file, tryEnc[idx]);
        },
        error:()=>{ 
          const fr=new FileReader(); 
          fr.onload=()=>{ 
            const parsed=Papa.parse(String(fr.result||''),{skipEmptyLines:'greedy'}); 
            let r=Array.isArray(parsed.data)?parsed.data:[]; 
            r=r.map(x=>Array.isArray(x)?x:[x]); 
            resolve(r); 
          }; 
          fr.onerror=()=>resolve([]); 
          fr.readAsText(file,'UTF-8'); 
        },
        skipEmptyLines:'greedy'
      });
    });
  }

  /* =================== 시트 헤더 & 공통 =================== */
  function buildHeader(){
    return ['A','B','C','D','E','F','G','H(결제금액)','I(상태)','J','K(결제시간)','L(결제수단)','M(환불금액)','N(환불일시)'];
  }

  // 카드: A..J → B..K, L='신용카드', M/N = 카드 CSV K/L, K 오름차순
  function processCardRows(rows, skipHeader=true){
    const out=[]; const start=skipHeader?1:0;
    for(let i=start;i<rows.length;i++){
      const r=rows[i]||[]; 
      if(r.length===0 || r.every(x=>String(x).trim()==='')) continue;
      const o=ensureArrayLen(14);  // A..N
      for(let j=0;j<10;j++){ o[1+j]=r[j]??''; } // B..K
      o[11]='신용카드';            // L
      o[12]= r[10] ?? o[12];      // M
      o[13]= r[11] ?? o[13];      // N
      out.push(o);
    }
    out.sort((a,b)=> (getTimeFromAny(a[10])||Infinity) - (getTimeFromAny(b[10])||Infinity));
    return out;
  }

  /* ===== 계좌: 국민 9370 전용 로직 =====
     F열: '현금매출' = 결제(+), '매출환입및에누리' = 환불(-)
     C열: 같은 값(전표/거래 ID)끼리 그룹 → 합계 0이면 '환불됨', 0 아니고 환불 있으면 '부분환불'
  */
  function makeBankRows(tickets, responses, skipT=true, skipR=true){
    if(!tickets.length) return [];

    const tHead = tickets[0] || [];
    const cDate = findColIndex(tHead, ['일시','거래일시','거래시간','승인일시','처리일시','date','time']);
    const cAmt  = findColIndex(tHead, ['금액','거래금액','입금액','출금액','amount']);

    // C열, F열 인덱스 (0-based)
    const IDX_GROUP = 2; // C열
    const IDX_TYPE  = 5; // F열

    // responses로 이름/연락처/이메일 보강
    const rHead = responses[0] || [];
    const rName = findColIndex(rHead, ['성함','이름','신청자','name']);
    const rEmail= findColIndex(rHead, ['이메일','email']);
    const rPhone= findColIndex(rHead, ['연락처','전화','휴대폰','phone','mobile']);

    const respMap = new Map();
    const rStart  = skipR ? 1 : 0;
    if(rName >= 0){
      for(let i=rStart;i<responses.length;i++){
        const rr = responses[i] || [];
        const nm = normName(rr[rName] || '');
        if(!nm) continue;
        if(!respMap.has(nm)){
          respMap.set(nm, {
            email: rEmail>=0 ? (rr[rEmail] || '') : '',
            phone: rPhone>=0 ? (rr[rPhone] || '') : ''
          });
        }
      }
    }

    // 이름 추출 (계좌적요/거래상대명/사용처)
    const cName = findColIndex(tHead, ['보낸분/받는분','거래상대명','거래처','성명','상대']);
    const cPlace= findColIndex(tHead, ['사용처','적요','내용','메모']);
    const cNote = findColIndex(tHead, ['계좌적요']);
    function pickCounterpartyName(row){
      let s = '';
      if(cNote >= 0) s = row[cNote] || '';
      if(!s && cName >= 0) s = row[cName] || '';
      if(!s && cPlace>= 0) s = row[cPlace] || '';
      s = String(s || '').trim();
      if(!s) return '';
      if(s.includes('←')) s = s.split('←')[0];
      if(s.includes('→')) s = s.split('→')[0];
      return normName(s);
    }

    // C열 그룹별로 매출/환불 묶기
    const groups = new Map(); // key: C, value: { sales: [], refunds: [] }
    const tStart = skipT ? 1 : 0;

    for(let i=tStart;i<tickets.length;i++){
      const r = tickets[i] || [];
      if(r.every(x => String(x).trim() === '')) continue;
      if(r.length <= Math.max(IDX_GROUP, IDX_TYPE)) continue;

      const groupKey = String(r[IDX_GROUP] ?? '').trim();
      if(!groupKey) continue;

      const typeCell = String(r[IDX_TYPE] ?? '').trim();
      const rawAmt   = cAmt>=0 ? parseMoney(r[cAmt]) : 0;
      const when     = cDate>=0 ? (r[cDate] || '') : '';

      const isSale   = typeCell.includes('현금매출');
      const isRefund = typeCell.includes('매출환입및에누리');

      if(!isSale && !isRefund) continue;

      let amtSigned = 0;
      if (isSale) {
        amtSigned = Math.abs(rawAmt);      // 매출은 양수
      } else if (isRefund) {
        amtSigned = -Math.abs(rawAmt);     // 환불은 음수
      }

      const nameN = pickCounterpartyName(r);
      let g = groups.get(groupKey);
      if(!g){
        g = { sales: [], refunds: [] };
        groups.set(groupKey, g);
      }

      if(isSale){
        g.sales.push({ when, amt: amtSigned, name: nameN });
      }else if(isRefund){
        g.refunds.push({ when, amt: amtSigned });
      }
    }

    const out = [];

    for(const [groupKey, g] of groups.entries()){
      if(!g.sales.length) continue; // 매출 없는 그룹은 스킵

      const saleSum   = g.sales.reduce((s,x)=> s + (x.amt || 0), 0);   // 양수합
      const refundSum = g.refunds.reduce((s,x)=> s + (x.amt || 0), 0); // 음수합
      const net       = saleSum + refundSum;
      const refundAmount = -refundSum; // 환불액(양수)

      let refundDate = '';
      if(g.refunds.length){
        g.refunds.sort((a,b)=> (getTimeFromAny(a.when)||0) - (getTimeFromAny(b.when)||0));
        refundDate = g.refunds[g.refunds.length - 1].when || '';
      }

      g.sales.sort((a,b)=> (getTimeFromAny(a.when)||0) - (getTimeFromAny(b.when)||0));
      const firstSale = g.sales[0];
      const nameN     = firstSale.name || '';
      const meta      = respMap.get(nameN) || { email:'', phone:'' };

      let status = '결제완료';
      if(refundAmount > 0){
        status = (net === 0) ? '환불됨' : '부분환불';
      }

      const row = ensureArrayLen(14); // A..N

      row[3]  = nameN;
      row[4]  = meta.phone;
      row[5]  = meta.email;
      row[6]  = '강의';
      row[7]  = saleSum;
      row[8]  = status;
      row[9]  = '면세';
      row[10] = firstSale.when;
      row[11] = '계좌이체';
      row[12] = refundAmount || '';
      row[13] = refundDate;

      out.push(row);
    }

    out.sort((a,b)=> (getTimeFromAny(a[10]) || Infinity) - (getTimeFromAny(b[10]) || Infinity));
    return out;
  }

  /* =================== 빌드 & 프리뷰 =================== */
  function buildFinalRows(){
    const header=buildHeader();
    const card = csvCard.length ? processCardRows(csvCard, $('#headCard').checked) : [];
    const bank = csvTickets.length ? makeBankRows(csvTickets, csvResp, $('#headTicket').checked, $('#headResp').checked) : [];
    parsedRows=[header, ...card, ...bank];
    $('#optHasHeader').checked=true;
  }

  function renderPreview(rows){
    const table=$('#previewTable'); table.innerHTML='';
    if(!rows.length){ $('#summary').textContent='행 0'; return; }

    const thead=document.createElement('thead');
    const tbody=document.createElement('tbody');
    const colCount=rows[0].length;

    if($('#optHasHeader').checked){
      const tr=document.createElement('tr');
      rows[0].forEach((h,idx)=>{ 
        const th=document.createElement('th'); 
        th.className='bg-slate-100 text-slate-700 font-semibold'; 
        th.textContent=h||`(col${idx+1})`; 
        tr.appendChild(th); 
      });
      thead.appendChild(tr);
    }
    const startIdx=$('#optHasHeader').checked?1:0;
    for(let r=startIdx;r<rows.length;r++){
      const tr=document.createElement('tr'), row=rows[r];
      for(let c=0;c<colCount;c++){
        const td=document.createElement('td'); 
        const v=(row[c]??'').toString();
        if(row.length!==colCount) td.classList.add('invalid');
        td.textContent=v; 
        tr.appendChild(td);
      }
      tbody.appendChild(tr);
    }
    table.appendChild(thead); 
    table.appendChild(tbody);
    const bodyRows=Math.max(0, rows.length-(startIdx));
    $('#summary').textContent=`열 ${colCount} · 데이터 행 ${bodyRows}`;
  }

  /* =================== 이벤트 =================== */
  window.addEventListener('error', e=> toast('오류: '+(e?.error?.message||e.message||'알 수 없는 오류'),'error'));
  window.addEventListener('unhandledrejection', e=> toast('처리되지 않은 오류: '+(e?.reason?.message||e.reason||'알 수 없는 오류'),'error'));

  document.addEventListener('DOMContentLoaded', ()=>{
    // 파일 업로드
    $('#csvCard').addEventListener('change', async (e)=>{
      try{
        const f=e.target.files?.[0]; 
        if(!f){ toast('카드 CSV 선택이 비었습니다','error'); return; }
        $('#nameCard').textContent = f.name;
        csvCard=await readCsv(f);
        const cnt=csvCard.filter(r=>Array.isArray(r)&&r.some(c=>String(c).trim()!=='')).length;
        toast(`카드 CSV 로드: ${csvCard.length}행 (유효 ${cnt}행)`, cnt?'ok':'error');
      }catch(err){ console.error(err); toast('카드 CSV 읽기 실패','error'); }
      finally{ e.target.value=''; }
    }, {capture:true});

    $('#csvTicket').addEventListener('change', async (e)=>{
      try{
        const f=e.target.files?.[0]; 
        if(!f){ toast('tickets CSV 선택이 비었습니다','error'); return; }
        $('#nameTicket').textContent = f.name;
        csvTickets=await readCsv(f);
        const cnt=csvTickets.filter(r=>Array.isArray(r)&&r.some(c=>String(c).trim()!=='')).length;
        toast(`tickets 로드: ${csvTickets.length}행 (유효 ${cnt}행)`, cnt?'ok':'error');
      }catch(err){ console.error(err); toast('tickets 읽기 실패','error'); }
      finally{ e.target.value=''; }
    }, {capture:true});

    $('#csvResp').addEventListener('change', async (e)=>{
      try{
        const f=e.target.files?.[0]; 
        if(!f){ toast('responses CSV 선택이 비었습니다','error'); return; }
        $('#nameResp').textContent = f.name;
        csvResp=await readCsv(f);
        const cnt=csvResp.filter(r=>Array.isArray(r)&&r.some(c=>String(c).trim()!=='')).length;
        toast(`responses 로드: ${csvResp.length}행 (유효 ${cnt}행)`, cnt?'ok':'error');
      }catch(err){ console.error(err); toast('responses 읽기 실패','error'); }
      finally{ e.target.value=''; }
    }, {capture:true});

    // 미리보기
    $('#btnPreviewCsv').addEventListener('click', (e)=>{
      e.preventDefault();
      try{
        if(!csvCard.length && !csvTickets.length){ 
          parsedRows=[buildHeader()]; 
          renderPreview(parsedRows); 
          toast('CSV를 업로드하세요 (헤더만 표시)','error'); 
          return; 
        }
        buildFinalRows();
        let rows=parsedRows;
        if($('#optMaskPhone').checked) rows=maskPhones(rows);
        rows=equalizeRowLength(rows);
        renderPreview(rows);
        toast('미리보기 갱신(카드→계좌, K 오름차순)','ok');
      }catch(err){ console.error(err); toast('정리 실패: 콘솔 확인','error'); }
    });

    // 초기화
    $('#btnClear').addEventListener('click', (e)=>{
      e.preventDefault();
      csvCard=[]; csvTickets=[]; csvResp=[]; parsedRows=[];
      $('#csvCard').value=''; $('#csvTicket').value=''; $('#csvResp').value='';
      $('#nameCard').textContent=''; $('#nameTicket').textContent=''; $('#nameResp').textContent='';
      $('#previewTable').innerHTML=''; $('#summary').textContent='';
      toast('초기화 완료');
    });

    // Google 연결
    $('#connectBtn').addEventListener('click', async (e)=>{
      e.preventDefault();
      try{
        if(OAUTH_CLIENT_ID.startsWith('REPLACE_WITH')){ 
          toast('OAuth 클라이언트 ID를 설정해 주세요.','error'); 
          return; 
        }
        await ensureGapiLoaded(); 
        await ensureAuth(); 
        $('#btnSend').disabled=false;
      }catch(err){ console.error(err); toast('Google 연결 실패','error'); }
    });

    // 시트 목록 불러오기
    $('#btnLoadSheets').addEventListener('click', async (e)=>{
      e.preventDefault();
      try{
        await ensureGapiLoaded();
        if(!oauthReady){ toast('먼저 Google 계정 연결을 해주세요','error'); return; }
        const spreadsheetId = parseSpreadsheetId($('#sheetUrl').value);
        if(!spreadsheetId){ toast('스프레드시트 URL/ID를 입력하세요','error'); return; }
        const titles = await listSheets(spreadsheetId);
        const sel = $('#sheetPicker'); sel.innerHTML='';
        if(!titles.length){ 
          sel.innerHTML = '<option value="">(시트 없음)</option>'; 
          return; 
        }
        titles.forEach(t => {
          const opt = document.createElement('option');
          opt.value = t; opt.textContent = t;
          sel.appendChild(opt);
        });
        toast(`시트 ${titles.length}개 불러옴`,'ok');
      }catch(err){ console.error(err); toast('시트 목록 불러오기 실패','error'); }
    });

    // 전송
    $('#btnSend').addEventListener('click', async (e)=>{
      e.preventDefault();
      try{
        await ensureGapiLoaded();
        if(!oauthReady){ toast('먼저 Google 계정 연결을 해주세요','error'); return; }
        if(!parsedRows.length){ toast('먼저 정리 미리보기를 실행하세요','error'); return; }
        const hasHeader=$('#optHasHeader').checked;
        const rowsToSend=hasHeader? parsedRows.slice(1): parsedRows;
        if(!rowsToSend.length){ toast('전송할 데이터 행이 없습니다','error'); return; }
        $('#btnSend').disabled=true;
        const updated=await writeFromB2(rowsToSend);
        toast(`전송 완료: ${updated}행`,'ok');
      }catch(err){ console.error(err); toast('전송 실패: 콘솔 확인','error'); }
      finally{ $('#btnSend').disabled=false; }
    });

    window.updateAuthUI = ()=>{ 
      $('#authState').textContent = oauthReady ? '연결됨' : '미연결'; 
    };
  });
  </script>
</body>
</html>
